# Desing Patterns 

This repository will contain examples of implementation of design patterns in Python. Also, this repository will serve as a study for me and for anyone who wants to learn more about design patterns.

---

Design patters are well-tested, reusable solutions. They are like templates of how to solve common software engineering problems. They are not finished designs that can be transformed directly into code. Instead, they are descriptions or templates for how to solve problems in a way that can be reused in many different situations.

They are optimal and save time and effort. They are not a one-size-fits-all solution, but they can be adapted to fit the needs of a specific project.

They are great because they set a pattern to other developers. They are a common language that can be used to communicate ideas and solutions. They are a way to share knowledge and experience. 

## Creational Patterns

They are design patterns that manage object creation mechanisms. they are designed to create objects in flexible and highly adaptable ways. These patterns offer the most reusable and flexbile ways of creatign object instances.

## Structural Patterns

They are design patterns that improev and simplyfy the design of existing code. They are concerned with how classes and objects are composed to form larger structures. They help ensure that if one part of a system changes, the entire system doesn't need to change. They are good to create complex hierarchies of classes and objects. They are also good to create complex relationships between classes and objects. They are

## Behavioral Patterns

They are design patterns that deal with how objects interact and communicate with each other. They are concerned with algorithms and the assignment of responsibilities between objects. They help ensure that if one part of a system changes, the entire system doesn't need to change. They are good to create complex hierarchies of classes and objects. They are also good to create complex relationships between classes and objects. They are good to create complex relationships between classes and objects.

## Why does we need Software Architecture?

Complex softwrares often has many components. These components need to work together to create a cohesive system. Software architecture is the process of defining a structured solution that meets all of the technical and operational requirements of the project while optimizing common quality attributes like performance, security, and manageability. It is the blueprint for the system.

Complex softwares are plagued with many issues, as:

1. Timelines are stretched

2. Multiple developers are working on the same codebase

3. Code redundancy

This dificulty the process of creating new features and fixing bugs. It also makes it difficult to maintain the codebase over time.

## Hallmakrs of a good architeture

1. Loose coupling - 
   - The components of the system should be loosely coupled. This means that the components should be independent of each other. This allows for easier maintenance and updates to the system. It also allows for easier testing of the system.
2. Separation of concerns - 
   - The components of the system should be separated by concerns. This means that each component should have a specific responsibility. This allows for easier maintenance and updates to the system. It also allows for easier testing of the system.
3. Law of Demeter - 
   - The components of the system should follow the law of Demeter. This means that each component should only communicate with its immediate neighbors. This allows for easier maintenance and updates to the system. It also allows for easier testing of the system.
4. SOLID principles - 
   - The components of the system should follow the SOLID principles. This means that each component should be single responsibility, open for extension, closed for modification, Liskov substitution, interface segregation, and dependency inversion. This allows for easier maintenance and updates to the system. It also allows for easier testing of the system.
   - The single-responsibility principle states that a class should have only one reason to change. This means that a class should only have one responsibility. This allows for easier maintenance and updates to the system. It also allows for easier testing of the system.
   - The open-closed principle states that a class should be open for extension but closed for modification. This means that a class should be able to be extended without modifying the existing code. This allows for easier maintenance and updates to the system. It also allows for easier testing of the system.
    - The Liskov substitution principle states that a class should be able to be replaced with its subclasses without affecting the behavior of the system. This means that a class should be able to be replaced with its subclasses without affecting the behavior of the system. This allows for easier maintenance and updates to the system. It also allows for easier testing of the system.
    - The interface segregation principle states that a class should not be forced to implement interfaces it does not use. This means that a class should not be forced to implement interfaces it does not use. This allows for easier maintenance and updates to the system. It also allows for easier testing of the system.
    - The dependency inversion principle states that a class should depend on abstractions rather than concrete implementations. This means that a class should depend on abstractions rather than concrete implementations. This allows for easier maintenance and updates to the system. It also allows for easier testing of the system.